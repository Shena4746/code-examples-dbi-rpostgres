---
title: "Code Examples for DBI and RPostgres"
author: "Shena"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
github-repo: 'Shena4746/datascience-100knocks-preprocess-R'
---

```{r setup, eval = TRUE, include=FALSE}
rm(list = ls())
gc(reset = TRUE)
gc(reset = TRUE)
knitr::opts_chunk$set(eval = TRUE, echo = TRUE, warning = FALSE)
```

# About DBI and RPostgres

```{r libraries, message=FALSE, warning=FALSE}
library("RPostgres")
library("DBI")
library("dbplyr")
library("dplyr")
```

This document is based on the following conditions.
```{r versions-of-libraries, collapse=TRUE}
R.version.string
packageVersion("RPostgres")
packageVersion("DBI")
packageVersion("dbplyr")
packageVersion("dplyr")
packageVersion("purrr")
```

## Overview

## List of Functions

### Functions in DBI 

```{r DBI-functions, collapse=TRUE}
# functions in dbi package
dbi <- ls("package:DBI")
dbi %>% length() # how many ?
dbi %>% print()
```

### Functions in RPostgres

```{r RPostgres-functions, collapse=TRUE}
# functions in RPostgres package
rpos <- ls("package:RPostgres")
rpos %>% length() # how many ?
rpos %>% print()
```

### Functions with duplicated names

You might have noticed that there are quite a few functions with the same name in these packages. They provides the same functionlaity, possibly with the different implementation and efficiecy.

```{r DBI-RPostgres-common-functions, collapse=TRUE}
# common functions in DBI and RPostgres
common <- base::intersect(dbi, rpos)
common %>% length() # how many ?
common %>% print()
```

We don't go into the (potentially deep) difference of these twin functions. This document prefers to using `DBI::` methods as introduced in [GitHub repository of RPostgres package](https://github.com/r-dbi/RPostgres), unless there is a significant difference between them. 

### Funcions only in DBI

```{r DBI-unique-functions, collapse=TRUE}
# functions only in DBI
only_in_dbi <- base::setdiff(dbi, rpos)
only_in_dbi %>% length() # how many ?
only_in_dbi %>% print()
```

### Funcions only in RPostgres

```{r RPostgres-unique-functions, collapse=TRUE}
# functions only in RPostgres
only_in_rpos <- base::setdiff(rpos, dbi)
only_in_rpos %>% length() # how many ?
only_in_rpos %>% print()
```

## Basic Usage

Before we look at each function, let us describe a typical work flow with these packages.
You may sefaly skip this section as it is independent of what follows.

This section assumes that you have access to a postgres database. If necessary, run the following command to create a new database named 'demo'.

```{bash start-postgres, eval=FALSE}
sudo service postgresql start
```

```{bash, eval=FALSE}
createdb -p 5432 --owner=your-owner-name --host=localhost --username=your-username demo
```

The following code defines the `con` variable which holds a establised connection to your database. 

```{r example-connect, eval = FALSE}
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = "localhost",
    port = 5432,
    dbname = "your-database-name",
    user = "your-user",
    password = "your-password"
)
```

You should not write this way outside this demo. See \@ref(dbConnect).

```{r example-issue-con, include=FALSE}
dw <- config::get("demo")
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = dw$host,
    port = dw$port,
    dbname = dw$dbname,
    user = dw$user,
    password = dw$password
)
```

Let us observe the list of tables in the connected database.

```{r empty-database, collapse=TRUE}
# demo database is empty
con %>% DBI::dbListTables()
```

`dbWriteTable()` Creates a remote table from local data.
The last argument is optional.

```{r our-first-table, collapse=TRUE}
# create table by supplying local dataframe
con %>% dbWriteTable("mtcars", mtcars, overwrite = TRUE)
con %>% dbWriteTable("iris", iris, overwrite = TRUE)
# check that tables are properly created
DBI::dbListTables(con)
```

You can also ask the existance of the specific table in the database associated with `con` variable.

```{r , collapse=TRUE}
# boolean question about the existance of indivisual table
con %>% DBI::dbExistsTable("mtcars")
```

`dbListFields()` gets you the list of fields of an indivisual table.

```{r list-fields-mtcars, collapse=TRUE}
# now we have
con %>% DBI::dbListFields("mtcars")
```

`dbReadTable()` allows you to take a quick peep at a table. 

```{r read-table-without-query}
con %>%
    DBI::dbReadTable("mtcars") %>%
    head()
```


You can use `dbSendQuery()` to execute a query written as a string. Note that we don't need a `;` at the end of the query. Since this method does nothing but sending query, you should keep the returned value to perform appropriate post-processing.

```{r first-send-query}
# send query and get response variable
rs <- con %>% DBI::dbSendQuery("
	SELECT *
	FROM mtcars
	WHERE hp <= 100
")
```

`dbFetch()` shows you the result of the query.

```{r first-fetch}
rs %>% DBI::dbFetch()
```

Don't forget to do `dbClearResult()`. 
DBI package keeps many kinds of resources associated with the result of the query unless manually cleared. `dbClearResult()` is responsible for that freeing role.
DBI reference says that 

> This step is mandatory for all objects obtained by calling dbSendQuery() or dbSendStatement().

```{r first-clear-result}
rs %>% dbClearResult()
```

We can write a parameterised query in the following way.
`$1` and `$2` corresponds to the first and second argument in the `list(100, 120)`, respectively. 

```{r first-param-query, collapse=TRUE}
rs <- con %>% dbSendQuery("
	SELECT *
	FROM mtcars
	WHERE hp BETWEEN $1 AND $2
")
rs %>% dbBind(list(100, 120))
rs %>% dbFetch()
rs %>% dbClearResult()
```

You can delete a table by `dbRemoveTable()`. 

```{r remove-tables}
# remove indivisual table by supplying name string
con %>% DBI::dbRemoveTable("mtcars")
```

It is often useful to have a function that deletes multiple tables at once based on a pre-defined rule.
The following code is one of the most simplest, deleting all tables.

```{r, collapse=TRUE}
# create mtcars table again to demonstate sumultaneous-removal
con %>% DBI::dbWriteTable("mtcars", mtcars, overwrite = TRUE)
DBI::dbListTables(con)
# remove multiple tables at once
con %>%
    DBI::dbListTables() %>%
    purrr::map_lgl(~ DBI::dbRemoveTable(con, .x)) %>%
    all()
DBI::dbListTables(con)
```

`dbDisconnect()` terminates the supplied `con` variable, and closes the connection. 

```{r first-dbDisconnect}
con %>% DBI::dbDisconnect()
```

<!--chapter:end:top.Rmd-->

# Functions in DBI and RPostgres {#Functions-dbi}

For convenience, we define a function that issues a connection variable. Here we use config package to avoid to write credentials in a code.

```{r issue-con}
# depends on config package
issue_con <- function(service_name) {
    dw <- config::get(service_name)
    DBI::dbConnect(
        drv = RPostgres::Postgres(),
        host = dw$host,
        port = dw$port,
        dbname = dw$dbname,
        user = dw$user,
        password = dw$password
    )
}
```

```{r def-remove-all-table, include=FALSE}
remove_all_table <- function(con) {
    con %>%
        DBI::dbListTables() %>%
        purrr::map_lgl(~ DBI::dbRemoveTable(con, .x)) %>%
        all()
}
```

<!--chapter:end:01-dbi.Rmd-->

## Connecting and Disconnecting

### `dbCanConnect()`

- Checks if a connection to a DBMS can be established
- Retruns logical.
- If `FALSE`, it comes with a reason for failure.

```{r can-connect, collapse=TRUE}
DBI::dbCanConnect(drv = RPostgres::Postgres())
RPostgres::dbCanConnect(drv = RPostgres::Postgres())
```

### `dbConnect()` {#dbConnect}

- Creates a connection to a DBMS.
- Retruns S4 object (that inherits from DBIConnection virtual class), which holds the established connection information used to communicate with database.
- Many connection variables can exist at the same time without affecting each other.

The following example shows a typical argument list for connecting to Postgres.

```{r, eval=FALSE}
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = "localhost",
    port = 5432,
    dbname = "your-database-name",
    user = "your-user",
    password = "your-password"
)
```

Be aware that this is a terrible way of connecting to a non-demo database because your credentials are completely revealed in a plain text. See [Securing Credentials](https://db.rstudio.com/best-practices/managing-credentials) for some better ways. In this document, we issue connection variables by calling `issue_con` defined in \@ref(Functions-dbi).

```{r, collapse=TRUE}
con <- issue_con("demo")
con %>% class()
con %>% mode()
con %>% typeof()
con %>% print()
```

### `dbDisconnect()`

- Closes the associated connection, discards all associated pending work, and frees resources.
- Retruns `TRUE` invisibly.
- Issues warning on an already disconnected connnectinon variable or invalid one.
- NOT clears a supplied connection object.

```{r disconnect-example, collapse=TRUE, warning=TRUE}
# disconnect con varibale. returns nothing.
con %>% dbDisconnect()
# get warned since con is already disconnected
con %>% dbDisconnect()
```

A disconnected object continues to exist as a non-null object.

```{r disconnected-alive, collapse=TRUE}
con %>% is.null()
con %>% class()
```

But it is no longer printable.

```{r disconnected-con-unpintable, collapse=TRUE, error=TRUE}
con %>% print()
```

Disconnection has a local effect. That is, disconnecting one connection has no impact on other connections.

```{r ,collapse=TRUE}
con <- issue_con("demo")
con1 <- issue_con("demo")
con1 %>% dbDisconnect()
# con is still valid
con %>% print()
```

### `dbGetInfo()`

- Retrieves information on database objects, i.e., DBIDriver (e.g., `RPostgres::Postgres`), DBIConnection (e.g., `con`) or DBIResult (e.g., `dbSendQuery()`).
- Returns a named list whose components depend on the input class.

```{r dbGetInfo, collapse=TRUE}
dbGetInfo(RPostgres::Postgres())
con %>% dbGetInfo()
```

### `dbIsReadOnly()`

- Tests whether a database object is read only.
- Returns logical.

```{r dbIsReadOnly, collapse=TRUE}
con %>% dbIsReadOnly()
dbIsReadOnly(RPostgres::Postgres())
```

```{r, include=FALSE}
con %>% dbDisconnect()
```

<!--chapter:end:0201-connect.Rmd-->

## Manipulating Tables

```{r ,include=FALSE}
con %>% dbDisconnect()
con <- issue_con("demo")
remove_all_table(con)
```

### `dbReadTable()`

- Copy data frames from database tables.
- Returns a data frame that contains the complete data from the remote table.

```{r read-table-example2, collapse=TRUE}
# prepare a table to read
con %>% dbWriteTable("mtcars", mtcars %>% head(), overwrite = TRUE)

con %>% dbReadTable("mtcars")
```


### `dbWriteTable()`

- Writes, overwrites or appends a data frame to a database table.
- Returns `TRUE` invisibly.
- Various optional argumets (must be provided as named arguments) available such as  
	- `temoprary = FALSE`: a logical specifying whether a created table should be temoprary in the sense that it vanishes after disconection. **NOT available with postgres**.
	- `overwrite = FALSE`: a logical specifying whether to overwrite an existing table.
	- `append = FALSE`: a logical specifying whether to append to an existing table.

```{r write-table-example1, collapse=TRUE}
# clear an old table, if exists
con %>% dbRemoveTable("mtcars", fail_if_missing = FALSE)

# create a new table
con %>% dbWriteTable(name = "mtcars", value = mtcars[1:2, ])
con %>% dbReadTable("mtcars")

# append rows to an exsiting table
con %>% dbWriteTable(name = "mtcars", value = mtcars[3:5, ], append = TRUE)
con %>% dbReadTable("mtcars")

# overwrite an existing table
con %>% dbWriteTable(name = "mtcars", value = mtcars %>% tail(), overwrite = TRUE)
con %>% dbReadTable("mtcars")
```

The following example demonstrates that `DBI::dbWriteTable()` does not accept `temoprary = ` option. Note that no error or warnig is raised. The same is true for `Postgres::dbWriteTable()`.

```{r write-mtcars-postgres, collapse=TRUE}
# temprary = TRUE is available?
con %>% RPostgres::dbWriteTable("mtcars", mtcars, overwrite = TRUE, temoprary = TRUE)

# show list of tables currently available
con %>% dbListTables()

# refresh connnection
con %>% dbDisconnect()
con <- issue_con("demo")

# is the table still alive? -> yes
con %>% dbListTables()
```


### `dbAppendTable()`

- Inserts rows into a table, assuming that the table has been created beforehand.
- Returns a scalar numeric equal to the number of rows inserted.
- The `row.names` argument must be `NULL`, the default value. The row names of input data are ignored.
- In Postgres, `DBI::dbAppendTable()` is overrideen by `RPostgres::dbAppendTable()` because RPostgres uses placeholders of the form `$1`, `$2` etc. instead of `?`.

```{r append-table-mtcars2, collapse=TRUE}
# create demo table
con %>% dbWriteTable("mtcars", mtcars %>% head(2), overwrite = TRUE)
# insert 10 rows from tail
con %>% DBI::dbAppendTable(name = "mtcars", value = mtcars %>% tail(10))
# show resulting table
con %>% dbReadTable("mtcars")
```

Appending rows into an absent table raises an error.

```{r append-absent-table, error=TRUE, collapse=TRUE}
con %>% dbAppendTable("iris", iris %>% head())
```

### `dbRemoveTable()`

- Removes a remote table from the database.
- Returns `TRUE` invisibly.
- Raises an error if the intended table does not exist (see `fail_if_missing` option below).
- Cannot remove a view in postges. (Neither DBI nor RPostgres has a method for dropping a view. It must be crafted by the user.)
- Additional options, which must be called as named ones, include
	- `temoprary = FALSE`: a logical specifying whether to consider only temprary tables. **NOT available with postgres**.
	- `fail_if_missing = TRUE`: a logical specifying whether to raise an error for the call to remove an absent table.

```{r remove-example1, collapse=TRUE}
if (con %>% dbExistsTable("mtcars") %>% isFALSE()) {
    con %>% dbWriteTable("mtcars", mtcars)
}

con %>% dbListTables()
con %>% dbRemoveTable("mtcars") # remove here
con %>% dbListTables() # removed table no longer exists
```

In Postgres, `temporary = TRUE` causes an error regardless of the existanece of the table.

```{r remove-temoprary-fails, error=TRUE, collapse=TRUE}
if (con %>% dbExistsTable("mtcars") %>% isFALSE()) {
    con %>% dbWriteTable("mtcars", mtcars)
}
con %>% dbRemoveTable("mtcars", temporary = TRUE) # error
```

In this case, the asked removal will not be executed.

```{r remove-temoprary-fails2, collapse=TRUE}
con %>% dbListTables() # the table is still alive
```

The following examples illustrate the behaviour of the option `fail_if_missing =`.

```{r remove-absent-table1, collapse=TRUE}
# fail_if_missing = FALSE makes an otherwise invalid call valid
con %>% dbRemoveTable("absent_table", fail_if_missing = FALSE)
```
```{r remove-absent-table2, error=TRUE, collapse=TRUE}
# fail_if_missing = TRUE, the default, raises an error for deleting an absent table
con %>% dbRemoveTable("absent_table")
```

### `dbListTables()`

- Returns a character vector that enumerates all tables and views in the database.
- In Postgres, this includes views and temprary objects created by `dplyr::copy_to()`, but not those by `dbplyr::copy_inline()`.

```{r ListTable, collapse=TRUE}
# prepare a table to list
con %>% dbWriteTable("mtcars", mtcars, overwrite = TRUE)
con %>% dbWriteTable("iris", iris, overwrite = TRUE)

lt <- con %>% dbListTables()
lt %>% class()
lt %>% mode()
lt %>% typeof()
lt %>% print()
```

### `dbListFields()`

- Returns a character vector that enumerates all fields in the table in the correct order.
- Works also for temprary tables created by `dplyr::copy_to()` in Postgres.

```{r Listfields, collapse=TRUE}
con %>% dbListFields("mtcars")
```

### `dbExistsTable()`

- Returns a logical scalar, `TRUE` if the table or view specified by the name argument exists, `FALSE` otherwise.
- Works also for temprary tables created by `dplyr::copy_to()` in Postgres.

```{r exsits-table, collapse=TRUE}
con %>% dbExistsTable("mtcars")
con %>% dbExistsTable("absent_table")
```

### `dbListObjects()`

- Returns a data frame with columns table and is_prefix in that order.
- Works also for temprary tables created by `dplyr::copy_to()` in Postgres.

```{r ListObj, collapse=TRUE}
# prepare a table to list
con %>% dbWriteTable("mtcars", mtcars, overwrite = TRUE)
con %>% dbWriteTable("iris", iris, overwrite = TRUE)

objs <- con %>% dbListObjects()
objs %>% class()
objs %>% mode()
objs %>% typeof()
objs %>% print()
```

```{r, include=FALSE}
remove_all_table(con)
con %>% DBI::dbDisconnect()
```

<!--chapter:end:0202-table.Rmd-->

## Queries and Statements

```{r, include=FALSE}
con %>% dbDisconnect()
con <- issue_con("demo")
```

This section uses the following tables as an example.
```{r queries-section-init, collapse=TRUE}
con %>% dbWriteTable("mtcars", mtcars, overwirte = TRUE)
con %>%
    dbReadTable("mtcars") %>%
    head()
```

### `dbGetQuery()`

- Executes a `SELECT` query written as a string.
- Returns the result, which is not stored as a result set contrary to `dbSendQuery()`.
- Comes with a default implementation that calls `dbSendQuery()` -> `dbFetch()` -> `dbClearResult()`.
- Returns a dataframe even if no rows are returned.
- Additional arguments
	- `n = -1`: specifies the number of rows to be fetched. `n = Inf` gives you the full result, `n = 0` the fully typed columns.
	- `param`: allows passing query parameters, see `dbBind()` for details.
	- `immediate`: see official reference.

You don't have to add `;` at the end of the query.
```{r getquery1, collapse=TRUE}
con %>% dbGetQuery("SELECT * FROM mtcars WHERE cyl >= 5", n = 5)
```

Sclar values in a query can be parameterized.

```{r getquery-param, collapse=TRUE}
con %>% dbGetQuery(
    "SELECT * FROM mtcars WHERE cyl = $1",
    params = list(1:5),
    n = 5
)
```

`dbGetQuery()` rejects multiple queries.

```{r cannot-get-multiple-queries, error=TRUE, collapse=TRUE}
con %>% dbGetQuery("SELECT * FROM mtcars WHERE cyl >= 5; SELECT 3.14 AS pi")
```

### `dbExecute()`

- Executes a statement. The result is not stored as a result set.
- Returns the number of rows affected. 
- Comes with a default implementation that calls `dbSendStatement()` -> `dbGetRowsAffected()` -> `dbClearResult()`.
- Additional arguments `params` and `immediate` are available as in `dbGetQuery()`.

```{r dbExecute, collapse=TRUE}
# newly create cars table
con %>% DBI::dbWriteTable("cars", cars %>% head(1), overwrite = TRUE)
con %>% dbReadTable("cars") # only 1 row

con %>% dbExecute(
    "INSERT INTO cars (speed, dist) VALUES ($1, $2)",
    params = list(1:4, 6:9)
)
con %>% dbReadTable("cars") # rows added
```

`dbExecute()` rejects multiple statements.

```{r cannot-executes-multiple-statements, error=TRUE, collapse=TRUE}
con %>% dbExecute("INSERT INTO cars (speed, dist) VALUES (7,21); DROP TABLE cars")
```

### `dbSendQuery()`

- Submits and synchronously executes the SQL query. Should be followed by `dbFetch()` and `dbClearResult()` to get and clear the pooled result. See [The data retrieval flow section in official reference](https://dbi.r-dbi.org/reference/dbsendquery).
- Returns an S4 object that inherits from DBIResult, called a result set.
- The returned result object should be stored in a variable.
- Additional arguments `params` and `immediate`.

Exactly the same parameterization method works as in `dbGetQuery()`.

```{r send-query-example1, collapse=TRUE}
rs <- con %>% dbSendQuery(
    "SELECT * FROM mtcars WHERE cyl = $1",
    params = list(4L)
)
rs %>% dbFetch(n = 5)
rs %>% dbClearResult()
```

`dbSendQuery()` gives us an alternative way of writing a parameterized query.

```{r send-query-example2, collapse=TRUE}
rs <- con %>% dbSendQuery(
    "SELECT * FROM mtcars WHERE cyl = $1"
)
rs %>% dbBind(list(4L))
rs %>% dbFetch(n = 5)
rs %>% dbClearResult()
```

### `dbSendStatement()`

- Submits and synchronously executes the SQL data manipulation statement (e.g., UPDATE, DELETE, INSERT INTO, DROP TABLE, ...).
- Returns a result object as in `dbSendQuery()`.
- The returned result set should be stored in a variable.
- A part of `dbExecute()`.
- Additional arguments `params` and `immediate`.

A typical parameterization through `params = list(...)` works.

```{r dbSendStatement-param, collapse=TRUE}
# overwirte cars table
con %>% DBI::dbWriteTable("cars", cars %>% head(1), overwrite = TRUE)
con %>% dbReadTable("cars")

# insert statement with typical parameterization
rs <- con %>% dbSendStatement(
    "INSERT INTO cars (speed, dist) VALUES ($1, $2)",
    params = list(1:4, 5:8)
)
dbClearResult(rs)
con %>% dbReadTable("cars")
```

You can also pass parameters by using `dbBind()`.

```{r dbSendStatement-param2, collapse=TRUE}
# overwirte cars table
con %>% DBI::dbWriteTable("cars", cars %>% head(1), overwrite = TRUE)
con %>% dbReadTable("cars")

# pass multiple parameter using dbBind()
rs <- dbSendStatement(
    con,
    "INSERT INTO cars (speed, dist) VALUES ($1, $2)"
)
dbBind(rs, list(2:3, 4:5))
dbBind(rs, list(6L, 7L))
dbClearResult(rs)
dbReadTable(con, "cars")
```

### `dbBind()`

- Binds placeholders in a parameterized/prepared statement to actual values.
- Returns a result set invisibly.
- Is intented to be called before calling `dbFetch()` or `dbGetRowsAffected()`.
- The placeholder syntax depends on DBMS.
	- `?`: RMySQL and RSQLite
	- `$1`: RPostgres and RSQLite
	- `:name` and `$name`: RSQLite.

```{r bind-params, collapse=TRUE}
con %>% dbWriteTable("iris", iris %>% head(), overwrite = TRUE)
rs <- con %>% dbSendQuery("SELECT * FROM iris WHERE 'Petal.Width' > $1")
rs %>% dbBind(list(3.0))
dbFetch(rs)
```

See `dbSendQuery` and `dbSendStatement` for more examples.

### `dbFetch(), fetch()`

- Fetches the next `n` elements (rows) from the result set.
- Returns a dataframe regardless of the result.
- For all new code, use `dbFetch()` not `fetch()` which is provided just for compatibility with older DBI-client. 

`dbFetch()` fetches unfetched results, as the next example shows.

```{r dbFetch-example1, collapse=TRUE}
rs <- con %>% dbSendQuery("SELECT mpg, cyl FROM mtcars LIMIT 10")
while (rs %>% dbHasCompleted() %>% isFALSE()) {
    chunk <- dbFetch(rs, 2)
    print(chunk)
}

dbClearResult(rs)
```

Not all result objects can be fetched.
One such example is the result of query with a unbounded placeholder.

```{r dbFetch-counter-example1, error=TRUE ,collapse=TRUE}
rs <- con %>% dbSendQuery("SELECT mpg, cyl, disp FROM mtcars WHERE cyl = $1")
rs %>% dbFetch(n = 5) # placeholder should be bound before being fetched
rs %>% dbBind(list(6L))
rs %>% dbClearResult()
```

More trivial result is a cleared result.

```{r dbFetch-counter-example2, error=TRUE ,collapse=TRUE}
rs %>% dbClearResult()
rs %>% dbFetch()
```

### `dbGetRowCount()`

- Counts the total number of rows **actually returned** by `dbFetch()` for the input result object.
- Returns a scalar number.

```{r get-row-count-example, collapse=TRUE}
rs <- dbSendQuery(con, "SELECT * FROM mtcars")

rs %>% dbGetRowCount() # initial value of the method

count_fetched_rows <- 0
while (!dbHasCompleted(rs)) {
    count_fetched_rows <- count_fetched_rows + nrow(rs %>% dbFetch(10))
}

count_fetched_rows # total number of rows fetched
rs %>% dbGetRowCount()

# fetching empty row has no effect on the value of dbGetRowCount()
rs %>% dbFetch()
rs %>% dbGetRowCount()

rs %>% dbClearResult()
```

`dbGetRowCount()` cannot count a cleared result.

```{r get-row-count-example2, error=TRUE,collapse=TRUE}
rs %>% dbGetRowCount()
```

### `dbGetRowsAffected()`

- Gets the number of rows affected by a data manipulation statement issued with dbSendStatement()
- Returns a scalar number, integer or numeric.

```{r dbGetRowsAffected-example1, collapse=TRUE}
con %>% dbWriteTable("cars", cars, overwrite = TRUE)
rs <- con %>% dbSendStatement("DELETE FROM cars WHERE dist >= 20")
rs %>% dbGetRowsAffected()
rs %>% dbClearResult()
```

The following example shows that `dbGetRowsAffected()` increases when placeholders get bounded, not when placeholders are placed.

```{r dbGetRowsAffected-example2, collapse=TRUE}
con %>% dbWriteTable("cars", cars, overwrite = TRUE)
rs <- con %>% dbSendStatement("DELETE FROM cars WHERE speed = $1 AND dist = $2")
rs %>% dbGetRowsAffected()
rs <- rs %>% dbBind(list(7, 21))
rs %>% dbGetRowsAffected() # there is no rows with that value
rs %>% dbClearResult()
```

### `dbGetStatement()`

- Gets the statement that was passed to `dbSendQuery()` or `dbSendStatement()`. It remains unchanged after placeholders are bounded afterwards.
- Returns a string statement.

```{r get-statement, collapse=TRUE}
con %>% dbWriteTable("cars", cars, overwrite = TRUE)
rs <- con %>% dbSendStatement("SELECT * FROM cars WHERE dist >= $1")
stm <- rs %>% dbGetStatement()
stm %>% class()
stm %>% print()
rs %>% dbBind(list(25))
rs %>% dbGetStatement() # unchanged!
rs %>% dbFetch(n = 5)
rs %>% dbClearResult()

# reuse the derived statement
rs <- con %>% dbSendStatement(stm)
rs %>% dbBind(list(35))
rs %>% dbFetch(n = 5)
rs %>% dbClearResult()
```

### `dbHasCompleted()`

- Tests if the associated operation has completed. 
- Returns a logical. `TRUE` if there is nothing more to be fetched and `FALSE` if otherwise.

`SELECT` statement completes when all results, if any, have been fetched.

```{r dbHasCompleted-example1, collapse=TRUE}
con %>% dbWriteTable("mtcars", mtcars, overwrite = TRUE)
rs <- con %>% dbSendQuery("SELECT * FROM mtcars")
rs %>% dbHasCompleted()
rs %>%
    dbFetch(n = 20) %>%
    invisible() # discard
rs %>% dbHasCompleted()
rs %>%
    dbFetch() %>%
    invisible() # discard
rs %>% dbHasCompleted()
rs %>% dbClearResult()
```

`SELECT` statement with no result rows completes as soon as the query is executed. Consequently, there is no need to fetch it to get it completed.

```{r dbHasCompleted-example2, collapse=TRUE}
con %>% dbWriteTable("mtcars", mtcars, overwrite = TRUE)
rs <- con %>% dbSendQuery("SELECT * FROM mtcars WHERE cyl = 5")
rs %>% dbHasCompleted()
rs %>% dbClearResult()
```

`DELETE`, `INSERT` and `UPDATE` statements get completed immediately after execution because there is originally nothing to fetch.

```{r dbHasCompleted-example3, collapse=TRUE}
con %>% dbWriteTable("cars", cars, overwrite = TRUE)
rs <- con %>% dbSendStatement("DELETE FROM cars WHERE speed >= 8")
rs %>% dbHasCompleted()
rs %>% dbClearResult()
```

### `dbColumnInfo()`

- Returns `data.frame` that describes the output of a query.
- A returned `data.frame` at least includes `"name"` and `"type"` followed by optional columns that starts with a dot such as `".oid"` and `".typname"` depending on DBMS.

```{r column-info-example, collapse=TRUE}
rs <- con %>% dbSendQuery(
    "
	SELECT 3.14 AS pi,
	0 AS unit_addition,
	'shena' AS author,
	current_date AS today
	"
)
info <- rs %>% dbColumnInfo()
info %>% class()
info %>% mode()
info %>% print()
rs %>% dbFetch(n = 0)
rs %>% dbClearResult()
```

Information about result types

### `dbClearResult()`

- Frees all resources (local and remote) associated with a result set.
- Returns `TRUE` invisibly.
- MUST follow `dbSendQuery()` and `dbSendStatement()`.

```{r clear-result-example, collapse=TRUE}
rs <- con %>% dbSendQuery("SELECT 3.14 AS pi")
rs %>% dbFetch()
rs %>% dbClearResult()
rs %>% dbClearResult() # clearing a cleared result again raises warning
```

<!--chapter:end:0203-queries.Rmd-->

## SQL

### `SQL()`

- Hndles SQL quoting.
- Returns a `SQL` class object. 
- See `dbQuoteIdentifier()` or `dbQuoteLiteral()` for similar (but different) quoting methods.
- See `sqlInterpolate()` for an application.
- `glue_sql()` in glue packages is also useful to deal with SQL escaping needs.

```{r sql-method-exampl1, collapse=TRUE}
con %>% dbDisconnect()
con <- issue_con("demo")
str <- c("SELECT", "WHERE")
s <- SQL(str)
s %>% class()
s %>% print()

SQL(s) %>% print() # unchanged

dbQuoteLiteral(con, s) %>% print() # SQL vectors pass through dbQuoteLiteral()

lt <- dbQuoteLiteral(con, str)
lt %>% print()

dbQuoteLiteral(con, lt) %>% print() # double escaping doesn't happen
```

### `dbDataType()`

- Describes the corresponding SQL data type for the DBMS.
- Returns a character string.
- Works without valid connection.

```{r sql-data-type, error=TRUE, collapse=TRUE}
con %>% dbDataType(Sys.Date()) # specify DB by connection
# works with a disconnected connection variable
con %>% dbDisconnect()
con %>% dbDataType(Sys.time())
con %>% dbDataType(Sys.time() - as.POSIXct(Sys.Date()))
con %>% dbDataType(c("pi", "e"))
con %>% dbDataType(list(raw(10), raw(20)))
con %>% dbDataType(I(1))
con %>% dbDataType(iris)
con %>% dbDataType(NA)
con %>% dbDataType(NULL) # error
```

You can also pass a `DBIDriver` object to specify the target DB.

```{r sql-data-type2,collapse=TRUE}
dbDataType(RPostgres::Postgres(), 1) # specify DB by driver
dbDataType(RPostgres::Postgres(), iris) %>% class()
```

### `dbQuoteIdentifier()`

### `dbQuoteLiteral()`

### `sqlInterpolate()`

- Create a SQL statement from a query string with a greater flexibility than `dbExecute()` or `dbGetQuery()`.
- Returns SQL of `SQL` class.
- Accepts placeholders with one of the following two syntaxes. They should be bounded by `.dots = list()`. 
	- `?,...,?`: bounded by an unnamed list.
	-  `?name1,...,?name2`: bounded by a named list.
- All values in `.dots = list()` will be first escaped with `dbQuoteLiteral()` to protect against SQL injection.

[DBI references](https://dbi.r-dbi.org/reference/sqlinterpolate) has many examples including several anti-patterns that should be taken care of.

```{r sql-interpolate-example1, collapse=TRUE}
con <- issue_con("demo")
sql <- "SELECT * FROM ?"
con %>% sqlInterpolate(
    sql = sql,
    .dots = list("mtcars" %>% dbQuoteIdentifier(con, .))
)
```

```{r sql-interpolate-example2, collapse=TRUE}
sql <- "SELECT ?p AS ?name"
stm <- con %>%
    sqlInterpolate(
        sql = sql,
        p = 3.14,
        name = "pi" %>% dbQuoteIdentifier(con, .)
    )
stm %>% print()

con %>% dbGetQuery(stm)
```

```{r sql-interpolate-example3, collapse=TRUE}
sql <- "DISCARD ?var"
all <- FALSE

con %>% sqlInterpolate(
    sql,
    var = if_else(all, "ALL", "TEMPORARY") %>% SQL()
)
```

<!--chapter:end:03-sql.Rmd-->

