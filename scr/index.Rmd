---
title: "Code Examples for DBI and RPostgres"
author: "Shena"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
github-repo: 'Shena4746/datascience-100knocks-preprocess-R'
---

```{r setup, eval = TRUE, include=FALSE}
rm(list = ls())
gc(reset = TRUE)
gc(reset = TRUE)
knitr::opts_chunk$set(eval = TRUE, echo = TRUE, warning = FALSE)
```

# About DBI and RPostgres

```{r libraries, message=FALSE, warning=FALSE}
library("RPostgres")
library("DBI")
library("dbplyr")
library("dplyr")
```

This document is based on the following conditions.
```{r versions-of-libraries, collapse=TRUE}
R.version.string
packageVersion("RPostgres")
packageVersion("DBI")
packageVersion("dbplyr")
packageVersion("dplyr")
packageVersion("purrr")
```

## Overview

## List of Functions

### Functions in DBI 

```{r DBI-functions, collapse=TRUE}
# functions in dbi package
dbi <- ls("package:DBI")
dbi %>% length() # how many ?
dbi %>% print()
```

### Functions in RPostgres

```{r RPostgres-functions, collapse=TRUE}
# functions in RPostgres package
rpos <- ls("package:RPostgres")
rpos %>% length() # how many ?
rpos %>% print()
```

### Functions with duplicated names

You might have noticed that there are quite a few functions with the same name in these packages. They provides the same functionlaity, possibly with the different implementation and efficiecy.

```{r DBI-RPostgres-common-functions, collapse=TRUE}
# common functions in DBI and RPostgres
common <- base::intersect(dbi, rpos)
common %>% length() # how many ?
common %>% print()
```

We don't go into the (potentially deep) difference of these twin functions. This document prefers to using `DBI::` methods as introduced in [GitHub repository of RPostgres package](https://github.com/r-dbi/RPostgres), unless there is a significant difference between them. 

### Funcions only in DBI

```{r DBI-unique-functions, collapse=TRUE}
# functions only in DBI
only_in_dbi <- base::setdiff(dbi, rpos)
only_in_dbi %>% length() # how many ?
only_in_dbi %>% print()
```

### Funcions only in RPostgres

```{r RPostgres-unique-functions, collapse=TRUE}
# functions only in RPostgres
only_in_rpos <- base::setdiff(rpos, dbi)
only_in_rpos %>% length() # how many ?
only_in_rpos %>% print()
```

## Basic Usage

Before we look at indivisual functions, let us describe a typical work flow with these packages.
You may sefaly skip this section as it is independent of what follows.

This section assumes that you have access to a postgres database. If necessary, run the following command to create a new database named 'demo'.

```{bash start-postgres, eval=FALSE}
sudo service postgresql start
```

```{bash, eval=FALSE}
createdb -p 5432 --owner=your-owner-name --host=localhost --username=your-username demo
```

The following code defines the `con` variable which keeps the establised connection to your database. 

```{r example-connect, eval = FALSE}
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = "localhost",
    port = 5432,
    dbname = "your-database-name",
    user = "your-user",
    password = "your-password"
)
```

You should not write this way outside this demo. See \@ref(dbConnect)

```{r example-issue-con, include=FALSE}
dw <- config::get("demo")
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = dw$host,
    port = dw$port,
    dbname = dw$dbname,
    user = dw$user,
    password = dw$password
)
```

Let us observe the list of tables in the connected database.

```{r empty-database, collapse=TRUE}
# demo database is empty
con %>% DBI::dbListTables()
```

`dbWriteTable()` Creates a remote table from local data.
The last two arguments are optional.

```{r our-first-table, collapse=TRUE}
# create table by supplying local dataframe
con %>% dbWriteTable("mtcars", mtcars, overwrite = TRUE)
con %>% dbWriteTable("iris", iris, overwrite = TRUE)
# check that tables are properly created
DBI::dbListTables(con)
```

You can also ask the existance of the specific table in the database associated with `con` variable.

```{r , collapse=TRUE}
# boolean question about the existance of indivisual table
con %>% DBI::dbExistsTable("mtcars")
```

`dbListFields()` gets you the list of fields of an indivisual table.

```{r list-fields-mtcars, collapse=TRUE}
# now we have
con %>% DBI::dbListFields("mtcars")
```

`dbReadTable()` allows you to take a quick peep at a table. 

```{r read-table-without-query}
con %>%
    DBI::dbReadTable("mtcars") %>%
    head()
```


You can use `dbSendQuery()` to execute a query written as a string. Note that we don't need a `;` at the end of the query. Since this method does nothing but sending query, you should capture the returned value to perform an appropriate post-processing.

```{r first-send-query}
# send query and get response variable
rs <- con %>% DBI::dbSendQuery("
	SELECT *
	FROM mtcars
	WHERE hp <= 100
")
```

`dbFetch()` shows you the result of the query.

```{r first-fetch}
rs %>% DBI::dbFetch()
```

Don't forget to do `dbClearResult()`. 
DBI package keeps many kinds of resources associated with the result of the query unless manually cleared. `dbClearResult()` is responsible for that freeing role.
DBI reference says that 

> This step is mandatory for all objects obtained by calling dbSendQuery() or dbSendStatement().

```{r first-clear-result}
rs %>% dbClearResult()
```

We can write a parameterised query in the following way.
`$1` and `$2` corresponds to the first and second argument in the `list(100, 120)`, respectively. 

```{r first-param-query, collapse=TRUE}
rs <- con %>% dbSendQuery("
	SELECT *
	FROM mtcars
	WHERE hp BETWEEN $1 AND $2
")
rs %>% dbBind(list(100, 120))
rs %>% dbFetch()
rs %>% dbClearResult()
```

You can delete a table by `dbRemoveTable()`. 

```{r remove-tables}
# remove indivisual table by supplying name string
con %>% DBI::dbRemoveTable("mtcars")
```

It is often useful to have a function that deletes multiple tables at once based on a pre-defined rule.
The following code is one of the most simplest, deleting all tables.

```{r, collapse=TRUE}
# create mtcars table again to demonstate sumultaneous-removal
con %>% DBI::dbWriteTable("mtcars", mtcars, overwrite = TRUE)
DBI::dbListTables(con)
# remove multiple tables at once
con %>%
    DBI::dbListTables() %>%
    purrr::map_lgl(~ DBI::dbRemoveTable(con, .x)) %>%
    all()
DBI::dbListTables(con)
```

`dbDisconnect()` terminates the supplied `con` variable, and closes the connection.

```{r first-dbDisconnect}
con %>% DBI::dbDisconnect()
```

<!--chapter:end:top.Rmd-->

# Functions in DBI and RPostgres {#Functions-dbi}

For convenience, we define a function that issues a connection variable.

```{r issue-con}
# depends on config package to handling credentials
issue_con <- function(service_name) {
    dw <- config::get(service_name)
    DBI::dbConnect(
        drv = RPostgres::Postgres(),
        host = dw$host,
        port = dw$port,
        dbname = dw$dbname,
        user = dw$user,
        password = dw$password
    )
}
```

```{r def-refresh-con, include=FALSE}
refresh_con <- function(x) {
    try(x %>% DBI::dbDisconnect())
    issue_con("demo")
}
```

```{r def-remove-all-table}
remove_all_table <- function(con) {
    con %>%
        DBI::dbListTables() %>%
        purrr::map_lgl(~ DBI::dbRemoveTable(con, .x)) %>%
        all()
}
```

<!--chapter:end:01-dbi.Rmd-->

## Connecting and Disconnecting

### `dbCanConnect()`

- Checks if a connection to a DBMS can be established
- Retruns logical.
- If `FALSE`, it comes with a reason for failure.

```{r can-connect, collapse=TRUE}
DBI::dbCanConnect(drv = RPostgres::Postgres())
RPostgres::dbCanConnect(drv = RPostgres::Postgres())
```

### `dbConnect()` {#dbConnect}

- Creates a connection to a DBMS.
- Retruns S4 object (that inherits from DBIConnection virtual class), which holds the established connection information used to communicate with database.
- Many connection variables can exist at the same time without affecting each other.

The following example shows a typical argument list for connecting to Postgres.

```{r, eval=FALSE}
con <- DBI::dbConnect(
    drv = RPostgres::Postgres(),
    host = "localhost",
    port = 5432,
    dbname = "your-database-name",
    user = "your-user",
    password = "your-password"
)
```

Be aware that this is a terrible way of connecting to a non-demo database because your credentials are completely revealed in a plain text. See [Securing Credentials](https://db.rstudio.com/best-practices/managing-credentials) for some better ways. In this document, we issue connection variables by calling `issue_con` defined in \@ref(Functions-dbi).

```{r, collapse=TRUE}
con <- issue_con("demo")
# connection variable is printable
con %>% print()
```

### `dbDisconnect()`

- Closes the associated connection, discards all associated pending work, and frees resources.
- Retruns `TRUE` invisibly.
- Issues warning on an already disconnected connnectinon variable or invalid one.
- NOT clears a supplied connection object.

```{r disconnect-example, collapse=TRUE, warning=TRUE}
# disconnect con varibale. returns nothing.
con %>% dbDisconnect()
# get warned since con is already disconnected
con %>% dbDisconnect()
```

A disconnected object continues to exist as a non-null object.

```{r disconnected-alive, collapse=TRUE}
con %>% is.null()
```

But it is no longer printable.

```{r disconnected-con-unpintable, collapse=TRUE, error=TRUE}
con %>% print()
```

Disconnection has a local effect. That is, disconnecting one connection has no impact on other connections.

```{r ,collapse=TRUE}
con <- issue_con("demo")
con1 <- issue_con("demo")
con1 %>% dbDisconnect()
# con is still valid
con %>% print()
```

### `dbGetInfo()`

- Retrieves information on database objects, i.e., DBIDriver (e.g., `RPostgres::Postgres`), DBIConnection (e.g., `con`) or DBIResult (e.g., `dbSendQuery()`).
- Returns a named list whose components depend on the input class.

```{r dbGetInfo, collapse=TRUE}
dbGetInfo(RPostgres::Postgres())
con %>% dbGetInfo()
```

### `dbIsReadOnly()`

- Tests whether a database object is read only.
- Returns logical.

```{r dbIsReadOnly, collapse=TRUE}
con %>% dbIsReadOnly()
dbIsReadOnly(RPostgres::Postgres())
```

```{r, include=FALSE}
con %>% dbDisconnect()
```

<!--chapter:end:0201-connect.Rmd-->

## Manipulating Tables

```{r ,include=FALSE}
con <- refresh_con(con)
remove_all_table(con)
```

### `dbWriteTable()`

- Writes, overwrites or appends a data frame to a database table
- Various optional argumets (must be provided as named arguments) available such as  
	- `temoprary = FALSE`: a logical specifying whether a created table should be temoprary in the sense that it vanishes after disconection. **NOT available with postgres**.
	- `overwrite = FALSE`: a logical specifying whether to overwrite an existing table.
	- `append = FALSE`: a logical specifying whether to append to an existing table.

The following example demonstrates that `DBI::dbWriteTable()` does not accept `temoprary = ` option. Note that no error or warnig is raised. The same is true for `Postgres::dbWriteTable()`.

```{r write-mtcars-postgres, collapse=TRUE}
# temprary = TRUE is available?
con %>% RPostgres::dbWriteTable("mtcars", mtcars, overwrite = TRUE, temoprary = TRUE)
# show list of tables currently available
con %>% dbListTables()
# refresh connnection
con %>% dbDisconnect()
con <- issue_con("demo")
# is the table still alive? -> yes
con %>% dbListTables()
```

### `dbListTables()`

- Returns a character vector that enumerates all tables and views in the database.
- In Postgres, this includes views and temprary objects created by `dplyr::copy_to()`, but not those by `dbplyr::copy_inline()`.

```{r ListTable, collapse=TRUE}
con %>% dbListTables()
```

### `dbListObjects()`

- Returns a data frame with columns table and is_prefix in that order.
- Works also for temprary tables created by `dplyr::copy_to()` in Postgres.

```{r ListObj, collapse=TRUE}
con %>% dbListObjects()
```

### `dbListFields()`

- Returns a character vector that enumerates all fields in the table in the correct order.
- Works also for temprary tables created by `dplyr::copy_to()` in Postgres.

```{r Listfields, collapse=TRUE}
con %>% dbListFields("mtcars")
```

### `dbExistsTable()`

- Returns a logical scalar, `TRUE` if the table or view specified by the name argument exists, `FALSE` otherwise.
- Works also for temprary tables created by `dplyr::copy_to()` in Postgres.

```{r exsits-table, collapse=TRUE}
con %>% dbExistsTable("mtcars")
con %>% dbExistsTable("hoge")
```

### `dbRemoveTable()`

- Removes a remote table from the database.
- Returns `TRUE` invisibly.
- Raises an error if the intended table does not exist (see `fail_if_missing` option below).
- Cannot remove a view in postges. (Neither DBI nor RPostgres has a method for dropping a view. It must be crafted by the user.)
- Additional options, which must be called as named ones, include
	- `temoprary = FALSE`: a logical specifying whether to consider only temprary tables. **NOT available with postgres**.
	- `fail_if_missing = TRUE`: a logical specifying whether to raise an error for the call to remove an absent table.

```{r remove-example1, collapse=TRUE}
if (con %>% dbExistsTable("mtcars") %>% isFALSE()) {
    con %>% dbWriteTable("mtcars", mtcars)
}

con %>% dbListTables()
con %>% dbRemoveTable("mtcars") # remove here
con %>% dbListTables() # removed table no longer exists
```

In Postgres, `temporary = TRUE` causes an error regardless of the existanece of the table.

```{r remove-temoprary-fails, error=TRUE, collapse=TRUE}
if (con %>% dbExistsTable("mtcars") %>% isFALSE()) {
    con %>% dbWriteTable("mtcars", mtcars)
}
con %>% dbRemoveTable("mtcars", temporary = TRUE) # error
```

In this case, the asked removal will not be executed.

```{r remove-temoprary-fails2, collapse=TRUE}
con %>% dbListTables() # the table is still alive
```

The following examples illustrate the behaviour of the option `fail_if_missing =`.

```{r remove-absent-table1, collapse=TRUE}
# fail_if_missing = FALSE makes an otherwise invalid call valid
con %>% dbRemoveTable("absent_table", fail_if_missing = FALSE)
```
```{r remove-absent-table2, error=TRUE, collapse=TRUE}
# fail_if_missing = TRUE, the default, raises an error for deleting an absent table
con %>% dbRemoveTable("absent_table")
```

### `dbReadTable()`

- Copy data frames from database tables.
- Returns a data frame that contains the complete data from the remote table.

```{r }
if (con %>% dbExistsTable("mtcars") %>% isFALSE()) {
    con %>% dbWriteTable("mtcars", mtcars)
}
con %>%
    dbReadTable("mtcars") %>%
    head()
```

### `dbAppendTable()`

- Inserts rows into a table, assuming that the table has been created beforehand.
- Returns a scalar numeric equal to the number of rows inserted.
- The `row.names` argument must be `NULL`, the default value. The row names of input data are ignored.
- In Postgres, `DBI::dbAppendTable()` is overrideen by `RPostgres::dbAppendTable()` because RPostgres uses placeholders of the form `$1`, `$2` etc. instead of `?`.

```{r append-table-mtcars2, collapse=TRUE}
# create demo table
con %>% dbWriteTable("mtcars2", mtcars %>% head(2), overwrite = TRUE)
# insert 10 rows from tail
con %>% DBI::dbAppendTable(name = "mtcars2", value = mtcars %>% tail(10))
# show resulting table
con %>% dbReadTable("mtcars2")
```

Appending rows into an absent table raises an error.

```{r append-absent-table, error=TRUE}
con %>% dbAppendTable("iris", iris %>% head())
```

```{r, include=FALSE}
remove_all_table(con)
con %>% DBI::dbDisconnect()
```

<!--chapter:end:0202-table.Rmd-->

## Queries and Statements

```{r, include=FALSE}
con <- refresh_con(con)
```

This section uses the following tables as an example.
```{r }
con %>% dbWriteTable("mtcars", mtcars, overwirte = TRUE)
con %>% dbListTables()
```

### `dbGetQuery()`

- Executes a `SELECT` query written as a string.
- Returns the result, which is not stored as a result set contrary to `dbSendQuery()`.
- Comes with a default implementation that calls `dbSendQuery()` -> `dbFetch()` -> `dbClearResult()`.
- Returns a dataframe even if no rows are returned.
- Additional arguments
	- `n = -1`: specifies the number of rows to be fetched. `n = Inf` gives you the full result, `n = 0` the fully typed columns.
	- `param`: allows passing query parameters, see `dbBind()` for details.
	- `immediate`: see official reference.


You don't have to add `;` at the end of the query.
```{r getquery1}
con %>% dbGetQuery("SELECT * FROM mtcars WHERE cyl >= 5", n = 5)
```

```{r getquery-param}
con %>% dbGetQuery(
    "SELECT * FROM mtcars WHERE cyl = $1",
    params = list(1:5),
    n = 5
)
```

### `dbExecute()`

- Executes a statement. The result is not stored as a result set.
- Returns the number of rows affected. 
- Comes with a default implementation that calls `dbSendStatement()` -> `dbGetRowsAffected()` -> `dbClearResult()`.
- Additional arguments `params` and `immediate` are available as in `dbGetQuery()`.

```{r dbExecute, collapse=TRUE}
# newly create cars table
con %>% DBI::dbWriteTable("cars", cars %>% head(1), overwrite = TRUE)
con %>% dbReadTable("cars") # only 1 row

con %>% dbExecute(
    "INSERT INTO cars (speed, dist) VALUES ($1, $2)",
    params = list(1:4, 6:9)
)
con %>% dbReadTable("cars") # rows added
```

### `dbSendQuery()`

- Submits and synchronously executes the SQL query. Should be followed by `dbFetch()` and `dbClearResult()` to get and clear the pooled result. See [The data retrieval flow section in official reference](https://dbi.r-dbi.org/reference/dbsendquery).
- Returns an S4 object that inherits from DBIResult, called a result set.
- The returned result object should be stored in a variable.
- Additional arguments `params` and `immediate`.

Exactly the same parameterization method works as in `dbGetQuery()`.

```{r send-query-example1, collapse=TRUE}
rs <- con %>% dbSendQuery(
    "SELECT * FROM mtcars WHERE cyl = $1",
    params = list(4L)
)
rs %>%
    dbFetch() %>%
    head()
rs %>% dbClearResult()
```

`dbSendQuery()` gives us an alternative way of writing a parameterized query.

```{r send-query-example2, collapse=TRUE}
rs <- con %>% dbSendQuery(
    "SELECT * FROM mtcars WHERE cyl = $1"
)
rs %>% dbBind(list(4L))
rs %>%
    dbFetch() %>%
    head()
rs %>% dbClearResult()
```

### `dbSendStatement()`

- Submits and synchronously executes the SQL data manipulation statement (e.g., UPDATE, DELETE, INSERT INTO, DROP TABLE, ...).
- Returns a result object as in `dbSendQuery()`.
- The returned result set should be stored in a variable.
- A part of `dbExecute()`.
- Additional arguments `params` and `immediate`.

A typical parameterization through `params = list(...)` works.

```{r dbSendStatement-param, collapse=TRUE}
# overwirte cars table
con %>% DBI::dbWriteTable("cars", cars %>% head(1), overwrite = TRUE)
con %>% dbReadTable("cars")

# insert statement with typical parameterization
rs <- con %>% dbSendStatement(
    "INSERT INTO cars (speed, dist) VALUES ($1, $2)",
    params = list(1:4, 5:8)
)
dbClearResult(rs)
con %>% dbReadTable("cars")
```

You can also pass parameters by using `dbBind()`.

```{r dbSendStatement-param2, collapse=TRUE}
# overwirte cars table
con %>% DBI::dbWriteTable("cars", cars %>% head(1), overwrite = TRUE)
con %>% dbReadTable("cars")

# pass multiple parameter using dbBind()
rs <- dbSendStatement(
    con,
    "INSERT INTO cars (speed, dist) VALUES ($1, $2)"
)
dbBind(rs, list(2:3, 4:5))
dbBind(rs, list(6L, 7L))
dbClearResult(rs)
dbReadTable(con, "cars")
```

### `dbBind()`

- Binds placeholders in a parameterized/prepared statement to actual values.
- Returns a result set invisibly.
- Is intented to be called before calling `dbFetch()` or `dbGetRowsAffected()`.
- The placeholder syntax depends on DBMS.
	- `?`: RMySQL and RSQLite
	- `$1`: RPostgres and RSQLite
	- `:name` and `$name`: RSQLite.

```{r bind-params, collapse=TRUE}
con %>% dbWriteTable("iris", iris %>% head(), overwrite = TRUE)
rs <- con %>% dbSendQuery("SELECT * FROM iris WHERE 'Petal.Width' > $1")
rs %>% dbBind(list(3.0))
dbFetch(rs)
```

See `dbSendQuery` and `dbSendStatement` for more examples.

### `dbFetch(), fetch()`

- Fetches the next `n` elements (rows) from the result set.
- Returns a dataframe regardless of the result.
- For all new code, use `dbFetch()` not `fetch()` which is provided just for compatibility with older DBI-client. 

`dbFetch()` fetches unfetched results, as the next example shows.

```{r dbFetch-example1, collapse=TRUE}
rs <- con %>% dbSendQuery("SELECT mpg, cyl FROM mtcars LIMIT 10")
while (rs %>% dbHasCompleted() %>% isFALSE()) {
    chunk <- dbFetch(rs, 2)
    print(chunk)
}

dbClearResult(rs)
```

Not all result objects can be fetched.
One such example is the result of query with a unbounded placeholder.

```{r dbFetch-counter-example1, error=TRUE ,collapse=TRUE}
rs <- con %>% dbSendQuery("SELECT mpg, cyl, disp FROM mtcars WHERE cyl = $1")
rs %>% dbFetch(n = 5) # placeholder should be bound before being fetched
rs %>% dbBind(list(6L))
rs %>% dbClearResult()
```

A more trivial result is a cleared result.

```{r dbFetch-counter-example2, error=TRUE ,collapse=TRUE}
rs %>% dbClearResult()
rs %>% dbFetch()
```

### `dbGetRowCount()`

- Counts the total number of rows **actually returned** by `dbFetch()` for the input result object.
- Returns a scalar number.

```{r get-row-count-example, collapse=TRUE}
rs <- dbSendQuery(con, "SELECT * FROM mtcars")

rs %>% dbGetRowCount() # initial value for the method

count_fetched_rows <- 0
while (!dbHasCompleted(rs)) {
    count_fetched_rows <- count_fetched_rows + nrow(rs %>% dbFetch(10))
}

count_fetched_rows # total number of rows fetched
rs %>% dbGetRowCount()

# fetching empty row has no effect on the value of dbGetRowCount()
rs %>% dbFetch()
rs %>% dbGetRowCount()

rs %>% dbClearResult()
```

`dbGetRowCount()` cannot count a cleared result.

```{r get-row-count-example2, error=TRUE,collapse=TRUE}
rs %>% dbGetRowCount()
```

### `dbGetRowsAffected()`

The number of rows affected

### `dbGetStatement()`

Get the statement associated with a result set

### `dbHasCompleted()`

Completion status

### `dbColumnInfo()`

Information about result types

### `dbClearResult()`

Clear a result set

<!--chapter:end:0203-queries.Rmd-->

