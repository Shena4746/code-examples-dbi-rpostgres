[["index.html", "Code Examples for DBI and RPostgres 1 What’s this? 2 About DBI and RPostgres 2.1 List of Functions 2.2 Basic Usage 3 Functions in DBI and RPostgres 3.1 Connecting and Disconnecting 3.2 Manipulating Tables 3.3 Queries and Statements 3.4 SQL 4 References: dbplyr, DBI, RPostgres", " Code Examples for DBI and RPostgres Shena 2022-07-11 1 What’s this? From README.md in Github repository: This repository is the R markdown source for the article Code Examples for DBI and RPostgres. Assuming you are using DBI with Postgres, it provides a brief overview of each DBI function and various code examples that illustrates how it is typically used and how it behaves. It is also intended to document minor tips that are not as well-documented as DBI official references. One important example is the actual behaviour of DBI functions. As implied in DBI specification, the behaviour of DBI functions, which depends on the R/DBMS implementation, may sometimes be slightly different from what is expected from the DBI documentation. In such cases, the user is required to learn where the gaps exist and how they are different, typically through ad-hoc experimentation. This is exactly where this article grows out of. As a result, the content tends to focus on tricky aspects at times. If you would like a more balanced explanation, then the official DBI references should still be your first choice. 2 About DBI and RPostgres DBI specification has a rich explanation. Here is a brief summary of what DBI and RPostgres are and their relationship: DBI (shor fo the database inteface) defines virtual classes such as DBIDriver, DBIConnection, and DBIResult, which is intended to serve as an interface for communitacation between R and R/DBMS. The connection to indivisual DBMS is provides by so-called DBI backend packages such as RSQLite, RPostgres, RMySQL, RSQLServe, etc. It also provides implementation for the DBI base classes mentioned above. What is sometimes confusing is the fact that the functionlaity of the base class might be extended or/and might not be fully supported by a particular backend. Also, the backed class is not so well documented as DBI. Unfortunately, these things also apply to RPostgres, which is one of the reason why some “experimentation” are needed as mentioned earlier. 2.1 List of Functions The following contents rely on the following packages. R.version.string ## [1] &quot;R version 4.2.0 (2022-04-22)&quot; packageVersion(&quot;RPostgres&quot;) ## [1] &#39;1.4.4.9000&#39; packageVersion(&quot;DBI&quot;) ## [1] &#39;1.1.3&#39; packageVersion(&quot;dbplyr&quot;) ## [1] &#39;2.2.1&#39; packageVersion(&quot;dplyr&quot;) ## [1] &#39;1.0.9&#39; packageVersion(&quot;purrr&quot;) ## [1] &#39;0.3.4&#39; 2.1.1 Functions in DBI # functions in dbi package dbi &lt;- ls(&quot;package:DBI&quot;) dbi %&gt;% length() # how many ? ## [1] 67 dbi %&gt;% print() ## [1] &quot;ANSI&quot; &quot;dbAppendTable&quot; &quot;dbBegin&quot; ## [4] &quot;dbBind&quot; &quot;dbBreak&quot; &quot;dbCallProc&quot; ## [7] &quot;dbCanConnect&quot; &quot;dbClearResult&quot; &quot;dbColumnInfo&quot; ## [10] &quot;dbCommit&quot; &quot;dbConnect&quot; &quot;dbCreateTable&quot; ## [13] &quot;dbDataType&quot; &quot;dbDisconnect&quot; &quot;dbDriver&quot; ## [16] &quot;dbExecute&quot; &quot;dbExistsTable&quot; &quot;dbFetch&quot; ## [19] &quot;dbGetConnectArgs&quot; &quot;dbGetDBIVersion&quot; &quot;dbGetException&quot; ## [22] &quot;dbGetInfo&quot; &quot;dbGetQuery&quot; &quot;dbGetRowCount&quot; ## [25] &quot;dbGetRowsAffected&quot; &quot;dbGetStatement&quot; &quot;dbHasCompleted&quot; ## [28] &quot;dbIsReadOnly&quot; &quot;dbIsValid&quot; &quot;dbListConnections&quot; ## [31] &quot;dbListFields&quot; &quot;dbListObjects&quot; &quot;dbListResults&quot; ## [34] &quot;dbListTables&quot; &quot;dbQuoteIdentifier&quot; &quot;dbQuoteLiteral&quot; ## [37] &quot;dbQuoteString&quot; &quot;dbReadTable&quot; &quot;dbRemoveTable&quot; ## [40] &quot;dbRollback&quot; &quot;dbSendQuery&quot; &quot;dbSendStatement&quot; ## [43] &quot;dbSetDataMappings&quot; &quot;dbUnloadDriver&quot; &quot;dbUnquoteIdentifier&quot; ## [46] &quot;dbWithTransaction&quot; &quot;dbWriteTable&quot; &quot;fetch&quot; ## [49] &quot;Id&quot; &quot;isSQLKeyword&quot; &quot;isSQLKeyword.default&quot; ## [52] &quot;make.db.names&quot; &quot;make.db.names.default&quot; &quot;show&quot; ## [55] &quot;SQL&quot; &quot;sqlAppendTable&quot; &quot;sqlAppendTableTemplate&quot; ## [58] &quot;sqlColumnToRownames&quot; &quot;sqlCommentSpec&quot; &quot;sqlCreateTable&quot; ## [61] &quot;sqlData&quot; &quot;sqlInterpolate&quot; &quot;SQLKeywords&quot; ## [64] &quot;sqlParseVariables&quot; &quot;sqlParseVariablesImpl&quot; &quot;sqlQuoteSpec&quot; ## [67] &quot;sqlRownamesToColumn&quot; 2.1.2 Functions in RPostgres # functions in RPostgres package rpos &lt;- ls(&quot;package:RPostgres&quot;) rpos %&gt;% length() # how many ? ## [1] 48 rpos %&gt;% print() ## [1] &quot;dbAppendTable&quot; &quot;dbBegin&quot; &quot;dbBind&quot; ## [4] &quot;dbCanConnect&quot; &quot;dbClearResult&quot; &quot;dbColumnInfo&quot; ## [7] &quot;dbCommit&quot; &quot;dbConnect&quot; &quot;dbCreateTable&quot; ## [10] &quot;dbDataType&quot; &quot;dbDisconnect&quot; &quot;dbDriver&quot; ## [13] &quot;dbExecute&quot; &quot;dbExistsTable&quot; &quot;dbFetch&quot; ## [16] &quot;dbGetInfo&quot; &quot;dbGetQuery&quot; &quot;dbGetRowCount&quot; ## [19] &quot;dbGetRowsAffected&quot; &quot;dbGetStatement&quot; &quot;dbHasCompleted&quot; ## [22] &quot;dbIsReadOnly&quot; &quot;dbIsValid&quot; &quot;dbListFields&quot; ## [25] &quot;dbListObjects&quot; &quot;dbListResults&quot; &quot;dbListTables&quot; ## [28] &quot;dbQuoteIdentifier&quot; &quot;dbQuoteLiteral&quot; &quot;dbQuoteString&quot; ## [31] &quot;dbReadTable&quot; &quot;dbRemoveTable&quot; &quot;dbRollback&quot; ## [34] &quot;dbSendQuery&quot; &quot;dbSendStatement&quot; &quot;dbUnloadDriver&quot; ## [37] &quot;dbUnquoteIdentifier&quot; &quot;dbWithTransaction&quot; &quot;dbWriteTable&quot; ## [40] &quot;Id&quot; &quot;Postgres&quot; &quot;postgresDefault&quot; ## [43] &quot;postgresHasDefault&quot; &quot;postgresIsTransacting&quot; &quot;postgresWaitForNotify&quot; ## [46] &quot;Redshift&quot; &quot;show&quot; &quot;sqlData&quot; 2.1.3 Functions with duplicated names # common functions in DBI and RPostgres common &lt;- base::intersect(dbi, rpos) common %&gt;% length() # how many ? ## [1] 42 common %&gt;% print() ## [1] &quot;dbAppendTable&quot; &quot;dbBegin&quot; &quot;dbBind&quot; ## [4] &quot;dbCanConnect&quot; &quot;dbClearResult&quot; &quot;dbColumnInfo&quot; ## [7] &quot;dbCommit&quot; &quot;dbConnect&quot; &quot;dbCreateTable&quot; ## [10] &quot;dbDataType&quot; &quot;dbDisconnect&quot; &quot;dbDriver&quot; ## [13] &quot;dbExecute&quot; &quot;dbExistsTable&quot; &quot;dbFetch&quot; ## [16] &quot;dbGetInfo&quot; &quot;dbGetQuery&quot; &quot;dbGetRowCount&quot; ## [19] &quot;dbGetRowsAffected&quot; &quot;dbGetStatement&quot; &quot;dbHasCompleted&quot; ## [22] &quot;dbIsReadOnly&quot; &quot;dbIsValid&quot; &quot;dbListFields&quot; ## [25] &quot;dbListObjects&quot; &quot;dbListResults&quot; &quot;dbListTables&quot; ## [28] &quot;dbQuoteIdentifier&quot; &quot;dbQuoteLiteral&quot; &quot;dbQuoteString&quot; ## [31] &quot;dbReadTable&quot; &quot;dbRemoveTable&quot; &quot;dbRollback&quot; ## [34] &quot;dbSendQuery&quot; &quot;dbSendStatement&quot; &quot;dbUnloadDriver&quot; ## [37] &quot;dbUnquoteIdentifier&quot; &quot;dbWithTransaction&quot; &quot;dbWriteTable&quot; ## [40] &quot;Id&quot; &quot;show&quot; &quot;sqlData&quot; 2.1.4 Funcions only in DBI # functions only in DBI only_in_dbi &lt;- base::setdiff(dbi, rpos) only_in_dbi %&gt;% length() # how many ? ## [1] 25 only_in_dbi %&gt;% print() ## [1] &quot;ANSI&quot; &quot;dbBreak&quot; &quot;dbCallProc&quot; ## [4] &quot;dbGetConnectArgs&quot; &quot;dbGetDBIVersion&quot; &quot;dbGetException&quot; ## [7] &quot;dbListConnections&quot; &quot;dbSetDataMappings&quot; &quot;fetch&quot; ## [10] &quot;isSQLKeyword&quot; &quot;isSQLKeyword.default&quot; &quot;make.db.names&quot; ## [13] &quot;make.db.names.default&quot; &quot;SQL&quot; &quot;sqlAppendTable&quot; ## [16] &quot;sqlAppendTableTemplate&quot; &quot;sqlColumnToRownames&quot; &quot;sqlCommentSpec&quot; ## [19] &quot;sqlCreateTable&quot; &quot;sqlInterpolate&quot; &quot;SQLKeywords&quot; ## [22] &quot;sqlParseVariables&quot; &quot;sqlParseVariablesImpl&quot; &quot;sqlQuoteSpec&quot; ## [25] &quot;sqlRownamesToColumn&quot; 2.1.5 Funcions only in RPostgres # functions only in RPostgres only_in_rpos &lt;- base::setdiff(rpos, dbi) only_in_rpos %&gt;% length() # how many ? ## [1] 6 only_in_rpos %&gt;% print() ## [1] &quot;Postgres&quot; &quot;postgresDefault&quot; &quot;postgresHasDefault&quot; ## [4] &quot;postgresIsTransacting&quot; &quot;postgresWaitForNotify&quot; &quot;Redshift&quot; 2.2 Basic Usage Before we look at each function, let us describe a typical work flow with these packages. You may sefaly skip this section as it is independent of what follows. This section assumes that you have access to a postgres database. If necessary, run the following command to create a new database named ‘demo’. sudo service postgresql start createdb -p 5432 --owner=your-owner-name --host=localhost --username=your-username demo The following code defines the con variable which holds a establised connection to your database. con &lt;- DBI::dbConnect( drv = RPostgres::Postgres(), host = &quot;localhost&quot;, port = 5432, dbname = &quot;your-database-name&quot;, user = &quot;your-user&quot;, password = &quot;your-password&quot; ) You should not write this way outside this demo. See 3.1.2. Let us observe the list of tables in the connected database. # demo database is empty con %&gt;% DBI::dbListTables() ## character(0) dbWriteTable() Creates a remote table from local data. The last argument is optional. # create table by supplying local dataframe con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE) con %&gt;% dbWriteTable(&quot;iris&quot;, iris, overwrite = TRUE) # check that tables are properly created DBI::dbListTables(con) ## [1] &quot;mtcars&quot; &quot;iris&quot; You can also ask the existance of the specific table in the database associated with con variable. # boolean question about the existance of indivisual table con %&gt;% DBI::dbExistsTable(&quot;mtcars&quot;) ## [1] TRUE dbListFields() gets you the list of fields of an indivisual table. # now we have con %&gt;% DBI::dbListFields(&quot;mtcars&quot;) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; dbReadTable() allows you to take a quick peep at a table. con %&gt;% DBI::dbReadTable(&quot;mtcars&quot;) %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 You can use dbSendQuery() to execute a query written as a string. Note that we don’t need a ; at the end of the query. Since this method does nothing but sending query, you should keep the returned value to perform appropriate post-processing. # send query and get response variable rs &lt;- con %&gt;% DBI::dbSendQuery(&quot; SELECT * FROM mtcars WHERE hp &lt;= 100 &quot;) dbFetch() shows you the result of the query. rs %&gt;% DBI::dbFetch() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 4 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 5 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 6 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 7 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 8 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 9 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Don’t forget to do dbClearResult(). DBI package keeps many kinds of resources associated with the result of the query unless manually cleared. dbClearResult() is responsible for that freeing role. DBI reference says that This step is mandatory for all objects obtained by calling dbSendQuery() or dbSendStatement(). rs %&gt;% dbClearResult() We can write a parameterised query in the following way. $1 and $2 corresponds to the first and second argument in the list(100, 120), respectively. rs &lt;- con %&gt;% dbSendQuery(&quot; SELECT * FROM mtcars WHERE hp BETWEEN $1 AND $2 &quot;) rs %&gt;% dbBind(list(100, 120)) rs %&gt;% dbFetch() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 4 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 5 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 6 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 rs %&gt;% dbClearResult() You can delete a table by dbRemoveTable(). # remove indivisual table by supplying name string con %&gt;% DBI::dbRemoveTable(&quot;mtcars&quot;) It is often useful to have a function that deletes multiple tables at once based on a pre-defined rule. The following code is one of the most simplest, deleting all tables. # create mtcars table again to demonstate sumultaneous-removal con %&gt;% DBI::dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE) DBI::dbListTables(con) ## [1] &quot;iris&quot; &quot;mtcars&quot; # remove multiple tables at once con %&gt;% DBI::dbListTables() %&gt;% purrr::map_lgl(~ DBI::dbRemoveTable(con, .x)) %&gt;% all() ## [1] TRUE DBI::dbListTables(con) ## character(0) dbDisconnect() terminates the supplied con variable, and closes the connection. con %&gt;% DBI::dbDisconnect() 3 Functions in DBI and RPostgres For convenience, we define a function that issues a connection variable. Here we use config package to avoid to write credentials in a code. # depends on config package issue_con &lt;- function(service_name) { dw &lt;- config::get(service_name) DBI::dbConnect( drv = RPostgres::Postgres(), host = dw$host, port = dw$port, dbname = dw$dbname, user = dw$user, password = dw$password ) } 3.1 Connecting and Disconnecting 3.1.1 dbCanConnect() Checks if a connection to a DBMS can be established Retruns logical. If FALSE, it comes with a reason for failure. DBI::dbCanConnect(drv = RPostgres::Postgres()) ## [1] TRUE RPostgres::dbCanConnect(drv = RPostgres::Postgres()) ## [1] TRUE 3.1.2 dbConnect() Creates a connection to a DBMS. Retruns S4 object (that inherits from DBIConnection virtual class), which holds the established connection information used to communicate with database. Many connection variables can exist at the same time without affecting each other. The following example shows a typical argument list for connecting to Postgres. con &lt;- DBI::dbConnect( drv = RPostgres::Postgres(), host = &quot;localhost&quot;, port = 5432, dbname = &quot;your-database-name&quot;, user = &quot;your-user&quot;, password = &quot;your-password&quot; ) Be aware that this is a terrible way of connecting to a non-demo database because your credentials are completely revealed in a plain text. See Securing Credentials for some better ways. In this document, we issue connection variables by calling issue_con defined in 3. con &lt;- issue_con(&quot;demo&quot;) con %&gt;% class() ## [1] &quot;PqConnection&quot; ## attr(,&quot;package&quot;) ## [1] &quot;RPostgres&quot; con %&gt;% mode() ## [1] &quot;S4&quot; con %&gt;% typeof() ## [1] &quot;S4&quot; con %&gt;% print() ## &lt;PqConnection&gt; demo@localhost:5432 3.1.3 dbDisconnect() Closes the associated connection, discards all associated pending work, and frees resources. Retruns TRUE invisibly. Issues warning on an already disconnected connnectinon variable or invalid one. NOT clears a supplied connection object. # disconnect con varibale. returns nothing. con %&gt;% dbDisconnect() # get warned since con is already disconnected con %&gt;% dbDisconnect() ## Warning in connection_release(conn@ptr): Already disconnected A disconnected object continues to exist as a non-null object. con %&gt;% is.null() ## [1] FALSE con %&gt;% class() ## [1] &quot;PqConnection&quot; ## attr(,&quot;package&quot;) ## [1] &quot;RPostgres&quot; But it is no longer printable. con %&gt;% print() ## Error: Invalid connection Disconnection has a local effect. That is, disconnecting one connection has no impact on other connections. This means that you have to manually disconnect every connection variable you have issued. con &lt;- issue_con(&quot;demo&quot;) con1 &lt;- issue_con(&quot;demo&quot;) con1 %&gt;% dbDisconnect() # con is still valid con %&gt;% print() ## &lt;PqConnection&gt; demo@localhost:5432 3.1.4 dbGetInfo() Retrieves information on database objects, i.e., DBIDriver (e.g., RPostgres::Postgres), DBIConnection (e.g., con) or DBIResult (e.g., dbSendQuery()). Returns a named list whose components depend on the input class. dbGetInfo(RPostgres::Postgres()) ## $driver.version ## [1] &#39;1.4.4.9000&#39; ## ## $client.version ## [1] &#39;12.11&#39; con %&gt;% dbGetInfo() ## $dbname ## [1] &quot;demo&quot; ## ## $host ## [1] &quot;localhost&quot; ## ## $port ## [1] &quot;5432&quot; ## ## $username ## [1] &quot;guest&quot; ## ## $protocol.version ## [1] 3 ## ## $server.version ## [1] 120011 ## ## $db.version ## [1] 120011 ## ## $pid ## [1] 18121 3.1.5 dbIsReadOnly() Tests whether a database object is read only. Returns logical. con %&gt;% dbIsReadOnly() ## [1] FALSE dbIsReadOnly(RPostgres::Postgres()) ## [1] FALSE 3.2 Manipulating Tables 3.2.1 dbReadTable() Copy data frames from database tables. Returns a data frame that contains the complete data from the remote table. # prepare a table to read con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars %&gt;% head(), overwrite = TRUE) con %&gt;% dbReadTable(&quot;mtcars&quot;) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 3.2.2 dbWriteTable() Writes, overwrites or appends a data frame to a database table. Returns TRUE invisibly. Various optional argumets (must be provided as named arguments) available such as temoprary = FALSE: a logical specifying whether a created table should be temoprary in the sense that it vanishes after disconection. NOT available with postgres. overwrite = FALSE: a logical specifying whether to overwrite an existing table. append = FALSE: a logical specifying whether to append to an existing table. # clear an old table, if exists con %&gt;% dbRemoveTable(&quot;mtcars&quot;, fail_if_missing = FALSE) # create a new table con %&gt;% dbWriteTable(name = &quot;mtcars&quot;, value = mtcars[1:2, ]) con %&gt;% dbReadTable(&quot;mtcars&quot;) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21 6 160 110 3.9 2.620 16.46 0 1 4 4 ## 2 21 6 160 110 3.9 2.875 17.02 0 1 4 4 # append rows to an exsiting table con %&gt;% dbWriteTable(name = &quot;mtcars&quot;, value = mtcars[3:5, ], append = TRUE) con %&gt;% dbReadTable(&quot;mtcars&quot;) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 # overwrite an existing table con %&gt;% dbWriteTable(name = &quot;mtcars&quot;, value = mtcars %&gt;% tail(), overwrite = TRUE) con %&gt;% dbReadTable(&quot;mtcars&quot;) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## 2 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## 3 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## 4 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## 5 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## 6 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 The following example demonstrates that DBI::dbWriteTable() does not accept temoprary = option. Note that no error or warnig is raised. The same is true for Postgres::dbWriteTable(). # temprary = TRUE is available? con %&gt;% RPostgres::dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE, temoprary = TRUE) # show list of tables currently available con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; # refresh connnection con %&gt;% dbDisconnect() con &lt;- issue_con(&quot;demo&quot;) # is the table still alive? -&gt; yes con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; 3.2.3 dbAppendTable() Inserts rows into a table, assuming that the table has been created beforehand. Returns a scalar numeric equal to the number of rows inserted. The row.names argument must be NULL, the default value. The row names of input data are ignored. In Postgres, DBI::dbAppendTable() is overrideen by RPostgres::dbAppendTable() because RPostgres uses placeholders of the form $1, $2 etc. instead of ?. # create demo table con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars %&gt;% head(2), overwrite = TRUE) # insert 10 rows from tail con %&gt;% DBI::dbAppendTable(name = &quot;mtcars&quot;, value = mtcars %&gt;% tail(10)) ## [1] 10 # show resulting table con %&gt;% dbReadTable(&quot;mtcars&quot;) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 4 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 5 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## 6 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 7 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 8 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 9 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## 10 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## 11 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## 12 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Appending rows into an absent table raises an error. con %&gt;% dbAppendTable(&quot;iris&quot;, iris %&gt;% head()) ## Error: Failed to initialise COPY: ERROR: relation &quot;iris&quot; does not exist 3.2.4 dbRemoveTable() Removes a remote table from the database. Returns TRUE invisibly. Raises an error if the intended table does not exist (see fail_if_missing option below). Cannot remove a view in postges. (Neither DBI nor RPostgres has a method for dropping a view. It must be crafted by the user.) Additional options, which must be called as named ones, include temoprary = FALSE: a logical specifying whether to consider only temprary tables. NOT available with postgres. fail_if_missing = TRUE: a logical specifying whether to raise an error for the call to remove an absent table. if (con %&gt;% dbExistsTable(&quot;mtcars&quot;) %&gt;% isFALSE()) { con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars) } con %&gt;% dbListTables() ## [1] &quot;mtcars&quot; con %&gt;% dbRemoveTable(&quot;mtcars&quot;) # remove here con %&gt;% dbListTables() # removed table no longer exists ## character(0) In Postgres, temporary = TRUE causes an error regardless of the existanece of the table. if (con %&gt;% dbExistsTable(&quot;mtcars&quot;) %&gt;% isFALSE()) { con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars) } con %&gt;% dbRemoveTable(&quot;mtcars&quot;, temporary = TRUE) # error ## Error: Failed to fetch row: ERROR: schema &quot;pg_temp&quot; does not exist In this case, the asked removal will not be executed. con %&gt;% dbListTables() # the table is still alive ## [1] &quot;mtcars&quot; The following examples illustrate the behaviour of the option fail_if_missing =. # fail_if_missing = FALSE makes an otherwise invalid call valid con %&gt;% dbRemoveTable(&quot;absent_table&quot;, fail_if_missing = FALSE) ## NOTICE: table &quot;absent_table&quot; does not exist, skipping # fail_if_missing = TRUE, the default, raises an error for deleting an absent table con %&gt;% dbRemoveTable(&quot;absent_table&quot;) ## Error: Failed to fetch row: ERROR: table &quot;absent_table&quot; does not exist 3.2.5 dbListTables() Returns a character vector that enumerates all tables and views in the database. In Postgres, this includes views and temprary objects created by dplyr::copy_to(), but not those by dbplyr::copy_inline(). # prepare a table to list con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE) con %&gt;% dbWriteTable(&quot;iris&quot;, iris, overwrite = TRUE) lt &lt;- con %&gt;% dbListTables() lt %&gt;% class() ## [1] &quot;character&quot; lt %&gt;% mode() ## [1] &quot;character&quot; lt %&gt;% typeof() ## [1] &quot;character&quot; lt %&gt;% print() ## [1] &quot;mtcars&quot; &quot;iris&quot; 3.2.6 dbListFields() Returns a character vector that enumerates all fields in the table in the correct order. Works also for temprary tables created by dplyr::copy_to() in Postgres. con %&gt;% dbListFields(&quot;mtcars&quot;) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; 3.2.7 dbExistsTable() Returns a logical scalar, TRUE if the table or view specified by the name argument exists, FALSE if otherwise. Works also for temprary tables created by dplyr::copy_to() in Postgres. con %&gt;% dbExistsTable(&quot;mtcars&quot;) ## [1] TRUE con %&gt;% dbExistsTable(&quot;absent_table&quot;) ## [1] FALSE 3.2.8 dbListObjects() Returns a data frame with columns named table and is_prefix in this order. Works also for temprary tables created by dplyr::copy_to() in Postgres. # prepare a table to list con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE) con %&gt;% dbWriteTable(&quot;iris&quot;, iris, overwrite = TRUE) objs &lt;- con %&gt;% dbListObjects() objs %&gt;% class() ## [1] &quot;data.frame&quot; objs %&gt;% mode() ## [1] &quot;list&quot; objs %&gt;% typeof() ## [1] &quot;list&quot; objs %&gt;% print() ## table is_prefix ## 1 &lt;Id&gt; table = mtcars FALSE ## 2 &lt;Id&gt; table = iris FALSE ## 3 &lt;Id&gt; schema = public TRUE ## 4 &lt;Id&gt; schema = information_schema TRUE ## 5 &lt;Id&gt; schema = pg_catalog TRUE 3.3 Queries and Statements This section uses the following tables as an example. con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars, overwirte = TRUE) con %&gt;% dbReadTable(&quot;mtcars&quot;) %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 3.3.1 dbGetQuery() Executes a SELECT query written as a string. Returns the result, which is not stored as a result set contrary to dbSendQuery(). Comes with a default implementation that calls dbSendQuery() -&gt; dbFetch() -&gt; dbClearResult(). Returns a dataframe even if no rows are returned. Additional arguments n = -1: specifies the number of rows to be fetched. n = Inf gives you the full result, n = 0 the fully typed columns. param: allows passing query parameters, see dbBind() for details. immediate: see official reference. You don’t have to add ; at the end of the query. con %&gt;% dbGetQuery(&quot;SELECT * FROM mtcars WHERE cyl &gt;= 5&quot;, n = 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 4 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 5 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Sclar values in a query can be parameterized. con %&gt;% dbGetQuery( &quot;SELECT * FROM mtcars WHERE cyl = $1&quot;, params = list(1:5), n = 5 ) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 4 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 5 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 dbGetQuery() rejects multiple queries. con %&gt;% dbGetQuery(&quot;SELECT * FROM mtcars WHERE cyl &gt;= 5; SELECT 3.14 AS pi&quot;) ## Error: Failed to prepare query: ERROR: cannot insert multiple commands into a prepared statement 3.3.2 dbExecute() Executes a statement. The result is not stored as a result set. Returns the number of rows affected. Comes with a default implementation that calls dbSendStatement() -&gt; dbGetRowsAffected() -&gt; dbClearResult(). Additional arguments params and immediate are available as in dbGetQuery(). # newly create cars table con %&gt;% DBI::dbWriteTable(&quot;cars&quot;, cars %&gt;% head(1), overwrite = TRUE) con %&gt;% dbReadTable(&quot;cars&quot;) # only 1 row ## speed dist ## 1 4 2 con %&gt;% dbExecute( &quot;INSERT INTO cars (speed, dist) VALUES ($1, $2)&quot;, params = list(1:4, 6:9) ) ## [1] 4 con %&gt;% dbReadTable(&quot;cars&quot;) # rows added ## speed dist ## 1 4 2 ## 2 1 6 ## 3 2 7 ## 4 3 8 ## 5 4 9 dbExecute() rejects multiple statements. con %&gt;% dbExecute(&quot;INSERT INTO cars (speed, dist) VALUES (7,21); DROP TABLE cars&quot;) ## Error: Failed to prepare query: ERROR: cannot insert multiple commands into a prepared statement 3.3.3 dbSendQuery() Submits and synchronously executes the SQL query. Should be followed by dbFetch() and dbClearResult() to get and clear the pooled result. See The data retrieval flow section in official reference. Returns an S4 object that inherits from DBIResult, called a result set. The returned result object should be stored in a variable. Additional arguments params and immediate. Exactly the same parameterization method works as in dbGetQuery(). rs &lt;- con %&gt;% dbSendQuery( &quot;SELECT * FROM mtcars WHERE cyl = $1&quot;, params = list(4L) ) rs %&gt;% dbFetch(n = 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 4 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 5 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 rs %&gt;% dbClearResult() dbSendQuery() gives us an alternative way of writing a parameterized query. rs &lt;- con %&gt;% dbSendQuery( &quot;SELECT * FROM mtcars WHERE cyl = $1&quot; ) rs %&gt;% dbBind(list(4L)) rs %&gt;% dbFetch(n = 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 2 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 3 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 4 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 5 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 rs %&gt;% dbClearResult() 3.3.4 dbSendStatement() Submits and synchronously executes the SQL data manipulation statement (e.g., UPDATE, DELETE, INSERT INTO, DROP TABLE, …). Returns a result object as in dbSendQuery(). The returned result set should be stored in a variable. A part of dbExecute(). Additional arguments params and immediate. A typical parameterization through params = list(...) works. # overwirte cars table con %&gt;% DBI::dbWriteTable(&quot;cars&quot;, cars %&gt;% head(1), overwrite = TRUE) con %&gt;% dbReadTable(&quot;cars&quot;) ## speed dist ## 1 4 2 # insert statement with typical parameterization rs &lt;- con %&gt;% dbSendStatement( &quot;INSERT INTO cars (speed, dist) VALUES ($1, $2)&quot;, params = list(1:4, 5:8) ) dbClearResult(rs) con %&gt;% dbReadTable(&quot;cars&quot;) ## speed dist ## 1 4 2 ## 2 1 5 ## 3 2 6 ## 4 3 7 ## 5 4 8 You can also pass parameters by using dbBind(). # overwirte cars table con %&gt;% DBI::dbWriteTable(&quot;cars&quot;, cars %&gt;% head(1), overwrite = TRUE) con %&gt;% dbReadTable(&quot;cars&quot;) ## speed dist ## 1 4 2 # pass multiple parameter using dbBind() rs &lt;- dbSendStatement( con, &quot;INSERT INTO cars (speed, dist) VALUES ($1, $2)&quot; ) dbBind(rs, list(2:3, 4:5)) dbBind(rs, list(6L, 7L)) dbClearResult(rs) dbReadTable(con, &quot;cars&quot;) ## speed dist ## 1 4 2 ## 2 2 4 ## 3 3 5 ## 4 6 7 3.3.5 dbBind() Binds placeholders in a parameterized/prepared statement to actual values. Returns a result set invisibly. Is intented to be called before calling dbFetch() or dbGetRowsAffected(). The placeholder syntax depends on DBMS. ?: RMySQL and RSQLite $1: RPostgres and RSQLite :name and $name: RSQLite. con %&gt;% dbWriteTable(&quot;iris&quot;, iris %&gt;% head(), overwrite = TRUE) rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT * FROM iris WHERE &#39;Petal.Width&#39; &gt; $1&quot;) rs %&gt;% dbBind(list(3.0)) dbFetch(rs) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa See dbSendQuery and dbSendStatement for more examples. 3.3.6 dbFetch(), fetch() Fetches the next n elements (rows) from the result set. Returns a dataframe regardless of the result. For all new code, use dbFetch() not fetch() which is provided just for compatibility with older DBI-client. dbFetch() fetches unfetched results, as the next example shows. rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT mpg, cyl FROM mtcars LIMIT 10&quot;) while (rs %&gt;% dbHasCompleted() %&gt;% isFALSE()) { chunk &lt;- dbFetch(rs, 2) print(chunk) } ## mpg cyl ## 1 21 6 ## 2 21 6 ## mpg cyl ## 1 22.8 4 ## 2 21.4 6 ## mpg cyl ## 1 18.7 8 ## 2 18.1 6 ## mpg cyl ## 1 14.3 8 ## 2 24.4 4 ## mpg cyl ## 1 22.8 4 ## 2 19.2 6 dbClearResult(rs) Not all result objects can be fetched. One such example is the result of query with a unbounded placeholder. rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT mpg, cyl, disp FROM mtcars WHERE cyl = $1&quot;) rs %&gt;% dbFetch(n = 5) # placeholder should be bound before being fetched ## Error: Query needs to be bound before fetching rs %&gt;% dbBind(list(6L)) rs %&gt;% dbClearResult() More trivial result is a cleared result. rs %&gt;% dbClearResult() rs %&gt;% dbFetch() ## Error: Invalid result set 3.3.7 dbGetRowCount() Counts the total number of rows actually returned by dbFetch() for the input result object. Returns a scalar number. rs &lt;- dbSendQuery(con, &quot;SELECT * FROM mtcars&quot;) rs %&gt;% dbGetRowCount() # initial value of the method ## [1] 0 count_fetched_rows &lt;- 0 while (!dbHasCompleted(rs)) { count_fetched_rows &lt;- count_fetched_rows + nrow(rs %&gt;% dbFetch(10)) } count_fetched_rows # total number of rows fetched ## [1] 32 rs %&gt;% dbGetRowCount() ## [1] 32 # fetching empty row has no effect on the value of dbGetRowCount() rs %&gt;% dbFetch() ## [1] mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;0 rows&gt; (or 0-length row.names) rs %&gt;% dbGetRowCount() ## [1] 32 rs %&gt;% dbClearResult() dbGetRowCount() cannot count a cleared result. rs %&gt;% dbGetRowCount() ## Error: Invalid result set 3.3.8 dbGetRowsAffected() Gets the number of rows affected by a data manipulation statement issued with dbSendStatement() Returns a scalar number, integer or numeric. con %&gt;% dbWriteTable(&quot;cars&quot;, cars, overwrite = TRUE) rs &lt;- con %&gt;% dbSendStatement(&quot;DELETE FROM cars WHERE dist &gt;= 20&quot;) rs %&gt;% dbGetRowsAffected() ## [1] 42 rs %&gt;% dbClearResult() The following example shows that dbGetRowsAffected() increases when placeholders get bounded, not when placeholders are placed. con %&gt;% dbWriteTable(&quot;cars&quot;, cars, overwrite = TRUE) rs &lt;- con %&gt;% dbSendStatement(&quot;DELETE FROM cars WHERE speed = $1 AND dist = $2&quot;) rs %&gt;% dbGetRowsAffected() ## [1] NA rs &lt;- rs %&gt;% dbBind(list(7, 21)) rs %&gt;% dbGetRowsAffected() # there is no rows with that value ## [1] 0 rs %&gt;% dbClearResult() 3.3.9 dbGetStatement() Gets the statement that was passed to dbSendQuery() or dbSendStatement(). It remains unchanged after placeholders are bounded afterwards. Returns a string statement. con %&gt;% dbWriteTable(&quot;cars&quot;, cars, overwrite = TRUE) rs &lt;- con %&gt;% dbSendStatement(&quot;SELECT * FROM cars WHERE dist &gt;= $1&quot;) stm &lt;- rs %&gt;% dbGetStatement() stm %&gt;% class() ## [1] &quot;character&quot; stm %&gt;% print() ## [1] &quot;SELECT * FROM cars WHERE dist &gt;= $1&quot; rs %&gt;% dbBind(list(25)) rs %&gt;% dbGetStatement() # unchanged! ## [1] &quot;SELECT * FROM cars WHERE dist &gt;= $1&quot; rs %&gt;% dbFetch(n = 5) ## speed dist ## 1 10 26 ## 2 10 34 ## 3 11 28 ## 4 12 28 ## 5 13 26 rs %&gt;% dbClearResult() # reuse the derived statement rs &lt;- con %&gt;% dbSendStatement(stm) rs %&gt;% dbBind(list(35)) rs %&gt;% dbFetch(n = 5) ## speed dist ## 1 13 46 ## 2 14 36 ## 3 14 60 ## 4 14 80 ## 5 15 54 rs %&gt;% dbClearResult() 3.3.10 dbHasCompleted() Tests if the associated operation has completed. Returns a logical. TRUE if there is nothing more to be fetched and FALSE if otherwise. SELECT statement completes when all results, if any, have been fetched. con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE) rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT * FROM mtcars&quot;) rs %&gt;% dbHasCompleted() ## [1] FALSE rs %&gt;% dbFetch(n = 20) %&gt;% invisible() # discard rs %&gt;% dbHasCompleted() ## [1] FALSE rs %&gt;% dbFetch() %&gt;% invisible() # discard rs %&gt;% dbHasCompleted() ## [1] TRUE rs %&gt;% dbClearResult() SELECT statement with no result rows completes as soon as the query is executed. Consequently, there is no need to fetch it to get it completed. con %&gt;% dbWriteTable(&quot;mtcars&quot;, mtcars, overwrite = TRUE) rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT * FROM mtcars WHERE cyl = 5&quot;) rs %&gt;% dbHasCompleted() ## [1] TRUE rs %&gt;% dbClearResult() DELETE, INSERT and UPDATE statements get completed immediately after execution because there is originally nothing to fetch. con %&gt;% dbWriteTable(&quot;cars&quot;, cars, overwrite = TRUE) rs &lt;- con %&gt;% dbSendStatement(&quot;DELETE FROM cars WHERE speed &gt;= 8&quot;) rs %&gt;% dbHasCompleted() ## [1] TRUE rs %&gt;% dbClearResult() 3.3.11 dbColumnInfo() Returns data.frame that describes the output of a query. A returned data.frame at least includes \"name\" and \"type\" followed by optional columns that starts with a dot such as \".oid\" and \".typname\" depending on DBMS. rs &lt;- con %&gt;% dbSendQuery( &quot; SELECT 3.14 AS pi, 0 AS unit_addition, &#39;shena&#39; AS author, current_date AS today &quot; ) info &lt;- rs %&gt;% dbColumnInfo() info %&gt;% class() ## [1] &quot;data.frame&quot; info %&gt;% mode() ## [1] &quot;list&quot; info %&gt;% print() ## name type .oid .known .typname ## 1 pi double 1700 TRUE numeric ## 2 unit_addition integer 23 TRUE int4 ## 3 author character 25 TRUE text ## 4 today double 1082 TRUE date rs %&gt;% dbFetch(n = 0) ## [1] pi unit_addition author today ## &lt;0 rows&gt; (or 0-length row.names) rs %&gt;% dbClearResult() 3.3.12 dbClearResult() Frees all resources (local and remote) associated with a result set. Returns TRUE invisibly. MUST be called dbSendQuery() and dbSendStatement(). Rposgres automatically cleans up the existing result setes associated connnection when a new dbSendQuery() and dbSendStatement() is called. So, Rposgres user don’t need to pay much attention to this method. rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT 3.14 AS pi&quot;) rs %&gt;% dbFetch() ## pi ## 1 3.14 rs %&gt;% dbClearResult() rs %&gt;% dbClearResult() # clearing a cleared result again causes warning ## Warning: Expired, result set already closed If you are using RPosgres, automatic clearing works. rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT 3.14 AS pi&quot;) rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT 2.71 AS napier&quot;) # this call induces auto-cleaning ## Warning in result_create(conn@ptr, statement, immediate): Closing open result ## set, cancelling previous query rs %&gt;% dbFetch() ## napier ## 1 2.71 rs %&gt;% dbClearResult() The automatic cleaning does not work if you are working on different connnection variables. Such situation should be avoided or be handled with care in general. con1 &lt;- issue_con(&quot;demo&quot;) # new connection rs &lt;- con %&gt;% dbSendQuery(&quot;SELECT 3.14 AS pi&quot;) rs1 &lt;- con1 %&gt;% dbSendQuery(&quot;SELECT 2.71 AS napier&quot;) # query with the new connection rs %&gt;% dbFetch() # no automatic cleaning ## pi ## 1 3.14 rs1 %&gt;% dbFetch() ## napier ## 1 2.71 rs1 %&gt;% dbClearResult() rs %&gt;% dbClearResult() con1 %&gt;% dbDisconnect() 3.4 SQL 3.4.1 SQL() Hndles SQL quoting. Returns a SQL class object. See dbQuoteIdentifier() or dbQuoteLiteral() for similar (but different) quoting methods. See sqlInterpolate() for an application. glue_sql() in glue packages is also useful to deal with SQL escaping needs. con %&gt;% dbDisconnect() con &lt;- issue_con(&quot;demo&quot;) str &lt;- c(&quot;SELECT&quot;, &quot;WHERE&quot;) s &lt;- SQL(str) s %&gt;% class() ## [1] &quot;SQL&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DBI&quot; s %&gt;% print() ## &lt;SQL&gt; SELECT ## &lt;SQL&gt; WHERE SQL(s) %&gt;% print() # unchanged ## &lt;SQL&gt; SELECT ## &lt;SQL&gt; WHERE dbQuoteLiteral(con, s) %&gt;% print() # SQL vectors pass through dbQuoteLiteral() ## &lt;SQL&gt; SELECT ## &lt;SQL&gt; WHERE lt &lt;- dbQuoteLiteral(con, str) lt %&gt;% print() ## &lt;SQL&gt; &#39;SELECT&#39; ## &lt;SQL&gt; &#39;WHERE&#39; dbQuoteLiteral(con, lt) %&gt;% print() # double escaping doesn&#39;t happen ## &lt;SQL&gt; &#39;SELECT&#39; ## &lt;SQL&gt; &#39;WHERE&#39; 3.4.2 dbDataType() Describes the corresponding SQL data type for the DBMS. Returns a character string. Works without valid connection. con %&gt;% dbDataType(Sys.Date()) # specify DB by connection ## [1] &quot;DATE&quot; # works with a disconnected connection variable con %&gt;% dbDisconnect() con %&gt;% dbDataType(Sys.time()) ## [1] &quot;TIMESTAMPTZ&quot; con %&gt;% dbDataType(Sys.time() - as.POSIXct(Sys.Date())) ## [1] &quot;TIME&quot; con %&gt;% dbDataType(c(&quot;pi&quot;, &quot;e&quot;)) ## [1] &quot;TEXT&quot; con %&gt;% dbDataType(list(raw(10), raw(20))) ## [1] &quot;BYTEA&quot; con %&gt;% dbDataType(I(1)) ## [1] &quot;DOUBLE PRECISION&quot; con %&gt;% dbDataType(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &quot;DOUBLE PRECISION&quot; &quot;DOUBLE PRECISION&quot; &quot;DOUBLE PRECISION&quot; &quot;DOUBLE PRECISION&quot; ## Species ## &quot;TEXT&quot; con %&gt;% dbDataType(NA) ## [1] &quot;BOOLEAN&quot; con %&gt;% dbDataType(NULL) # error ## Error: Unsupported type You can also pass a DBIDriver object to specify the target DB. dbDataType(RPostgres::Postgres(), 1) # specify DB by driver ## [1] &quot;DOUBLE PRECISION&quot; dbDataType(RPostgres::Postgres(), iris) %&gt;% class() ## [1] &quot;character&quot; 3.4.3 dbQuoteIdentifier() 3.4.4 dbQuoteLiteral() 3.4.5 sqlInterpolate() Create a SQL statement from a query string with a greater flexibility than dbExecute() or dbGetQuery(). Returns SQL of SQL class. Accepts placeholders with one of the following two syntaxes. They should be bounded by .dots = list(). ?,...,?: bounded by an unnamed list. ?name1,...,?name2: bounded by a named list. All values in .dots = list() will be first escaped with dbQuoteLiteral() to protect against SQL injection. DBI references has many examples including several anti-patterns that should be taken care of. con &lt;- issue_con(&quot;demo&quot;) sql &lt;- &quot;SELECT * FROM ?&quot; con %&gt;% sqlInterpolate( sql = sql, .dots = list(&quot;mtcars&quot; %&gt;% dbQuoteIdentifier(con, .)) ) ## &lt;SQL&gt; SELECT * FROM &quot;mtcars&quot; sql &lt;- &quot;SELECT ?p AS ?name&quot; stm &lt;- con %&gt;% sqlInterpolate( sql = sql, p = 3.14, name = &quot;pi&quot; %&gt;% dbQuoteIdentifier(con, .) ) stm %&gt;% print() ## &lt;SQL&gt; SELECT 3.14::float8 AS &quot;pi&quot; con %&gt;% dbGetQuery(stm) ## pi ## 1 3.14 sql &lt;- &quot;DISCARD ?var&quot; all &lt;- FALSE con %&gt;% sqlInterpolate( sql, var = if_else(all, &quot;ALL&quot;, &quot;TEMPORARY&quot;) %&gt;% SQL() ) ## &lt;SQL&gt; DISCARD TEMPORARY 4 References: dbplyr, DBI, RPostgres Overview 巨大なデータがSQLサーバーにあるときに、Rでどう立ち向かうかマニュアル：dbplyrパッケージを中心として Introduction to dbplyr R: Working with Databases Introduction to DBI DBI RSQLite &amp; DBIの使い方 Code Examples for DBI and RPostgres DBI Reference DBI specification DBI: R Database Interface .pdf RPostgres RPostgres - Reference "]]
